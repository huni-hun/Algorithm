# 문제

### 난이도 : 골드 4

길이가 N인 수열이 주어졌을 때, 그 수열의 합을 구하려고 한다. 하지만, 그냥 그 수열의 합을 모두 더해서 구하는 것이 아니라, 수열의 두 수를 묶으려고 한다. 어떤 수를 묶으려고 할 때, 위치에 상관없이 묶을 수 있다. 하지만, 같은 위치에 있는 수(자기 자신)를 묶는 것은 불가능하다. 그리고 어떤 수를 묶게 되면, 수열의 합을 구할 때 묶은 수는 서로 곱한 후에 더한다.

예를 들면, 어떤 수열이 {0, 1, 2, 4, 3, 5}일 때, 그냥 이 수열의 합을 구하면 0+1+2+4+3+5 = 15이다. 하지만, 2와 3을 묶고, 4와 5를 묶게 되면, 0+1+(2*3)+(4*5) = 27이 되어 최대가 된다.

수열의 모든 수는 단 한번만 묶거나, 아니면 묶지 않아야한다.

수열이 주어졌을 때, 수열의 각 수를 적절히 묶었을 때, 그 합이 최대가 되게 하는 프로그램을 작성하시오.

# 입력

첫째 줄에 수열의 크기 N이 주어진다. N은 50보다 작은 자연수이다. 둘째 줄부터 N개의 줄에 수열의 각 수가 주어진다. 수열의 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.

# 출력

수를 합이 최대가 나오게 묶었을 때 합을 출력한다. 정답은 항상 231보다 작다.

# 느낀점

그리디문제. 문제를 어느정도 풀다보니 입력값을 보고 시간초과나 메모리 초과가 나올지 대충(?) 견적이 나오기 시작했다. 이 문제는 입력값 자체는 큰 편이 아니었기에 반복문을 충분히 사용해도 괜찮을 것 같았고, 문제를 풀기위해선 정렬이 필요해보여 바로 정렬해주었다. 뭔가 특별히 설명하기에는 어떤 이론적인 기술을 사용하진 않았고, 정렬 된 값들에서 음수들을 먼저 곱해주거나 냅두거나 처리를 해준뒤, 양수도 곱해주거나 곱하지 않는 것들은 더해주었다. 반복문을 돌면서 불린형 배열을 체크하면서 아직 사용하지 않은 값들을 계속 더해주는 방식으로 풀었다. 사실 처음부터 이렇게 짜야겠다 하면서 짠건아니고. 끄적끄적 짜다보니까 이렇게하면 될거같은데? 이런 느낌으로 코드를 작성했다. 어쨋든 값들이 잘나오는 것 같아 제출했는데 첫 제출은 잘가다가 실패가 나와서 코드를 자세히 살펴보니 조건문에 >= 부등호 실수가 있어서 수정 후 제출하고 솔브할 수 있었다. 기분탓인지 유독 그리디 문제에서 정렬과 조건문을 자주 사용하는 것 같은데, 저런 사소한 실수를 조심해야겠다.

# 걸린 시간

1시간
