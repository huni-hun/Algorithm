# 문제

### 난이도 : 골드 1

오늘은 직사각형 모양의 방을 로봇 청소기를 이용해 청소하려고 한다. 이 로봇 청소기는 유저가 직접 경로를 설정할 수 있다.

방은 크기가 1×1인 정사각형 칸으로 나누어져 있으며, 로봇 청소기의 크기도 1×1이다. 칸은 깨끗한 칸과 더러운 칸으로 나누어져 있으며, 로봇 청소기는 더러운 칸을 방문해서 깨끗한 칸으로 바꿀 수 있다.

일부 칸에는 가구가 놓여져 있고, 가구의 크기도 1×1이다. 로봇 청소기는 가구가 놓여진 칸으로 이동할 수 없다. 

로봇은 한 번 움직일 때, 인접한 칸으로 이동할 수 있다. 또, 로봇은 같은 칸을 여러 번 방문할 수 있다.

방의 정보가 주어졌을 때, 더러운 칸을 모두 깨끗한 칸으로 만드는데 필요한 이동 횟수의 최솟값을 구하는 프로그램을 작성하시오.

# 입력

입력은 여러 개의 테스트케이스로 이루어져 있다.

각 테스트 케이스의 첫째 줄에는 방의 가로 크기 w와 세로 크기 h가 주어진다. (1 ≤ w, h ≤ 20) 둘째 줄부터 h개의 줄에는 방의 정보가 주어진다. 방의 정보는 4가지 문자로만 이루어져 있으며, 각 문자의 의미는 다음과 같다.

    .: 깨끗한 칸
    *: 더러운 칸
    x: 가구
    o: 로봇 청소기의 시작 위치

더러운 칸의 개수는 10개를 넘지 않으며, 로봇 청소기의 개수는 항상 하나이다.

입력의 마지막 줄에는 0이 두 개 주어진다.

# 출력

각각의 테스트 케이스마다 더러운 칸을 모두 깨끗한 칸으로 바꾸는 이동 횟수의 최솟값을 한 줄에 하나씩 출력한다. 만약, 방문할 수 없는 더러운 칸이 존재하는 경우에는 -1을 출력한다.

# 느낀점

BFS와 인접리스트, 순열을 이용해 푸는 문제. 처음에 문제를 보고 BFS만 이용해서 풀 수 있는 문제라고 생각했다. 방문체크를 3차원 변수를 이용해 처리하면 왔던 곳을 다시 방문할 수 있고 먼지 제거도 잘 될거라 생각했다. 문제는 무조건 가까운 쪽으로 가는 경우보다 어떤 경로냐에 따라서 최소값들이 바뀌기에 해당 부분을 어떻게 처리해야될지 생각이 나지 않았다. 결국 포기하고 다른 분들의 설명을 참고해보니, BFS를 이용해 각 지점들의 거리를 계산해 저장해놓고 이후, 해당 거리를 순열을 이용해 모든 경우의수를 확인하여 최소값을 찾아내는 방식이었다. 알고리즘을 오랜만에 푼거도 있지만, 굉장히 수준높은 문제였다. BFS를 이런식으로 활용하여 노드를 뽑아내 푸는 방식을 배울 수 있어 좋은 문제경험이었다.

# 걸린 시간

2시간
