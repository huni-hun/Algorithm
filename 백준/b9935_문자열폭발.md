# 문제

### 난이도 : 골드 4

상근이는 문자열에 폭발 문자열을 심어 놓았다. 폭발 문자열이 폭발하면 그 문자는 문자열에서 사라지며, 남은 문자열은 합쳐지게 된다.

폭발은 다음과 같은 과정으로 진행된다.

    - 문자열이 폭발 문자열을 포함하고 있는 경우에, 모든 폭발 문자열이 폭발하게 된다. 남은 문자열을 순서대로 이어 붙여 새로운 문자열을 만든다.
    - 새로 생긴 문자열에 폭발 문자열이 포함되어 있을 수도 있다.
    - 폭발은 폭발 문자열이 문자열에 없을 때까지 계속된다.

상근이는 모든 폭발이 끝난 후에 어떤 문자열이 남는지 구해보려고 한다. 남아있는 문자가 없는 경우가 있다. 이때는 "FRULA"를 출력한다.

폭발 문자열은 같은 문자를 두 개 이상 포함하지 않는다.

# 입력

첫째 줄에 문자열이 주어진다. 문자열의 길이는 1보다 크거나 같고, 1,000,000보다 작거나 같다.
둘째 줄에 폭발 문자열이 주어진다. 길이는 1보다 크거나 같고, 36보다 작거나 같다.
두 문자열은 모두 알파벳 소문자와 대문자, 숫자 0, 1, ..., 9로만 이루어져 있다.

# 출력

첫째 줄에 모든 폭발이 끝난 후 남은 문자열을 출력한다.

# 느낀점

처음 문제가 요구하는 대로만 작성했을 땐, replaceAll을 이용해 처리해줬다. 작성하고보니 20줄 남짓의 굉장히 간단한 코드라 이게 정답일리가 없지 하면서도 제출하니 40프로대에서 메모리가 초과되었다. replace가 안된다면 split으로 나눠준뒤, stringBuilder로 다시 합쳐주는 방식으로 하면 어떨까하고 진행해봤으나 조금 진행도가 올랐을 뿐 다시 메모리가 초과되었다. replace만의 문제가 아닌 문자의 길이가 길어 contains를 사용하는 부분에서 메모리가 터진거같았다. 어떤 방식으로 풀어야할지 감이 잘안와 알고리즘분류를 보니 자료구조와 스택이있었다. charactor 스택을 만들어 하나하나 추가해주며 폭탄의 길이보다 길어지면 폭탄을 포함하는지 비교하는 방식으로 풀어주니 메모리 초과없이 잘 솔브되었다. 코드를 작성하면서 단순 눈에보이는 연산은 솔브되는 코드가 훨씬 많을텐데, 내장함수를 이용하는 과정에서 우리 눈에 보이지 않는 연산들이 많아 메모리가 터지는 것을 보며 느낀 부분이 있는 좋은 문제였다.

# 걸린 시간

40분
