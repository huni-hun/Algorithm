# 문제

### 난이도 : 골드 2

반지름이 1, 2, ..., N인 원판이 크기가 작아지는 순으로 바닥에 놓여있고, 원판의 중심은 모두 같다. 원판의 반지름이 i이면, 그 원판을 i번째 원판이라고 한다. 각각의 원판에는 M개의 정수가 적혀있고, i번째 원판에 적힌 j번째 수의 위치는 (i, j)로 표현한다. 수의 위치는 다음을 만족한다.

- (i, 1)은 (i, 2), (i, M)과 인접하다.
- (i, M)은 (i, M-1), (i, 1)과 인접하다.
- (i, j)는 (i, j-1), (i, j+1)과 인접하다. (2 ≤ j ≤ M-1)
- (1, j)는 (2, j)와 인접하다.
- (N, j)는 (N-1, j)와 인접하다.
- (i, j)는 (i-1, j), (i+1, j)와 인접하다. (2 ≤ i ≤ N-1)

아래 그림은 N = 3, M = 4인 경우이다.

![그림](https://upload.acmicpc.net/5968435b-a1af-4e2a-a612-baff989f44b2/-/preview/)

원판의 회전은 독립적으로 이루어진다. 2번 원판을 회전했을 때, 나머지 원판은 회전하지 않는다. 원판을 회전시킬 때는 수의 위치를 기준으로 하며, 회전시킨 후의 수의 위치는 회전시키기 전과 일치해야 한다.

다음 그림은 원판을 회전시킨 예시이다.

![그림](https://upload.acmicpc.net/977a4e67-5aa7-40d4-92ee-5f59ac75aadb/-/preview/)

원판을 아래와 같은 방법으로 총 T번 회전시키려고 한다. 원판의 회전 방법은 미리 정해져 있고, i번째 회전할때 사용하는 변수는 xi, di, ki이다.

1. 번호가 xi의 배수인 원판을 di방향으로 ki칸 회전시킨다. di가 0인 경우는 시계 방향, 1인 경우는 반시계 방향이다.
2. 원판에 수가 남아 있으면, 인접하면서 수가 같은 것을 모두 찾는다.
   1. 그러한 수가 있는 경우에는 원판에서 인접하면서 같은 수를 모두 지운다.
   2. 없는 경우에는 원판에 적힌 수의 평균을 구하고, 평균보다 큰 수에서 1을 빼고, 작은 수에는 1을 더한다.

원판을 T번 회전시킨 후 원판에 적힌 수의 합을 구해보자.

# 입력

첫째 줄에 N, M, T이 주어진다.

둘째 줄부터 N개의 줄에 원판에 적힌 수가 주어진다. i번째 줄의 j번째 수는 (i, j)에 적힌 수를 의미한다.

다음 T개의 줄에 xi, di, ki가 주어진다.

# 출력

원판을 T번 회전시킨 후 원판에 적힌 수의 합을 출력한다.

# 느낀점

구현/시뮬레이션 문제. 구현 문제인 만큼 코드가 많이 나왔고 메소드를 많이 만들어서 순서대로 잘 처리하는게 중요한 문제였다. 만약, 예제에 친절한 설명이 없었으면 못풀었을 문제인데, 예제가 잘 나와있어서 시행착오를 겪어가며 풀었던 문제. 쉬운데 헷갈렸던 부분은 배열의 시계방향과 반시계 방향으로 돌릴때 순서를 바꿔주는 부분인데, 알고리즘을 처음 배울 때 푸는건데 오랜만에하니 헷갈렸다. 이후 구현하면서 두 부분이 걸렸는데,
첫 번째는, 인접한 값을 찾을 때 배열의 시작점과 끝점의 탐색부분을 안넣어줬던 것이다. 두 번째는, 인접한 값을 찾았을 때 0으로 바꿔주면서 연산했는데, 그렇게하면 다른 인접값을 탐색하지 못하는 오류가 발생했다. 그래서 0으로 바꿔주지않고 따로 boolean배열을 생성해서 해당 부분들을 true로 체킹해주고 마지막에 0으로 바꿔주니 해결되었다. 많은 메서드를 필요로하고 오랜 시간이 걸린 문제이지만, 내 방식으로 문제를 풀고 뿌듯함을 느낄 수 있었던 문제.

# 걸린 시간

2시간
