# 문제

### 난이도 : 골드 3

알파벳 대문자가 한 칸에 한 개씩 적혀있는 N×M 크기의 문자판이 있다. 편의상 모든 문자는 대문자라 생각하자. 예를 들어 아래와 같은 문자판을 보자.

K A K T
X E A S
Y R W U
Z B Q P

이 문자판의 한 칸(아무 칸이나 상관없음)에서 시작하여 움직이면서, 그 칸에 적혀 있는 문자들을 차례대로 모으면 하나의 단어를 만들 수 있다. 움직일 때는 상하좌우로 K개의 칸까지만 이동할 수 있다. 예를 들어 K=2일 때 아래의 그림의 가운데에서는 'X' 표시된 곳으로 이동할 수 있다.

X
X
X X X X
X
X

반드시 한 칸 이상 이동을 해야 하고, 같은 자리에 머물러 있을 수 없다. 또, 같은 칸을 여러 번 방문할 수 있다.

이와 같은 문자판과 K, 그리고 하나의 영단어가 주어졌을 때, 이와 같은 영단어를 만들 수 있는 경로가 총 몇 개 존재하는지 알아내는 프로그램을 작성하시오.

위의 예에서 영단어가 BREAK인 경우에는 다음과 같이 3개의 경로가 존재한다. 앞의 수는 행 번호, 뒤의 수는 열 번호를 나타낸다.

(4, 2) (3, 2) (2, 2) (1, 2) (1, 1)
(4, 2) (3, 2) (2, 2) (1, 2) (1, 3)
(4, 2) (3, 2) (2, 2) (2, 3) (1, 3)

# 입력

첫째 줄에 N(1 ≤ N ≤ 100), M(1 ≤ M ≤ 100), K(1 ≤ K ≤ 5)가 주어진다. 다음 N개의 줄에는 M개의 알파벳 대문자가 주어지는데, 이는 N×M 크기의 문자판을 나타낸다. 다음 줄에는 1자 이상 80자 이하의 영단어가 주어진다. 모든 문자들은 알파벳 대문자이며, 공백 없이 주어진다.

# 출력

첫째 줄에 경로의 개수를 출력한다. 이 값은 231-1보다 작거나 같다.

# 느낀점

완전탐색 + DP + DFS문제. 처음 문제를 보자마자 생각난 방법은 BFS였다. DFS랑도 고민했지만, 가장 편하게 푸는 방식으로 String 변수와 좌표, 그리고 단계를 담을 클래스를 하나 생성해서 BFS로 돌려주는 방법을 생각했고 바로 코드를 작성해서 제출했다. 메모리 초과가 나왔고, 사실 골드 3이 이렇게 간단히 안풀릴거라고 생각했기에 다시 고민해봤지만 어떤 식으로 풀어야할지 감이 잘 오질 않았다. 검색해보니 DP + DFS를 이용해서 푸는 문제였는데, DP는 아직 미숙하여 블로그 글을 한번 정독하고 다시 코드를 작성했다. 평소 내가 어려워하는 점화식을 세워서 작성하는 DP보다는 더 간단해보이는 문제였다. 목표 단어의 길이만큼 DP 3차원 배열을 생성하고 -1 로 채워준다. 이후 -1, 0, 1 을 통해 방문했는지 여부를 체크하고 만약 단어 완성이 가능하다면 1을 리턴해줘서 결과적으로 단어가 완성되는 총 경우의 수를 파악할 수 있다. DP를 이런식으로 이용해서 문제를 풀 수 있는 것을 배웠고 다시 한번 풀어보면 좋을 것 같은 문제였다.

# 걸린 시간

1시간 10분
